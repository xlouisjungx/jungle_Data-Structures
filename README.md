# 정글 8기-53번 사용

The practicing sequence could be `Linked List` -> `Stack n Queue` -> `Binary Tree` -> `Binary Search Tree`.


Approperiate `steps` to do each question: **Read the question's requirement in question sheet -> Find the corresponding main frame and copy it to your C compiler, i.e. Code::Block -> Finish the function part -> Try compiling and input some test cases.**
***

The main frames of each question are provided such that the function part is left empty for you to write and fill in the blank to complete the question. Basic functionalities like `POP/PUSH/DEQUEUE/ENQUEUE/REMOVE_LINKED_NODE/FIND_LINKED_NODE` are already provided in the main frame. You don't need to write these basic functions.

These questions only illustrate some basis of Data Structure. However, they can be your keys of the door to new world of CS. After finishing these questions, you may have a brief view of what the Data Structure is.

* 포인터
	- 메모리 주소를 저장하는 변수.
		- *p : 포인터가 가리키는 주소의 값을 가져온다.(역참조)
		- &a : 변수 a의 주소
* 포인터의 연산
        - 포인터끼리 연산이 가능하다. 배열과도 밀접한 관련이 있다고 한다.
                - p + 1: 다음 정수형 주소로 이동 (4바이트씩 증가)
                - 배열 탐색이나 동적 메모리에서 유용

* 가상화(Virtualization)
	- 물리적 컴퓨터 자원을 논리적으로 분리하는 기술. 시스템 프로그래밍에서 중요.
		- 예) 하나의 물리 서버에서 여러 개의 가상 서버를 운영(VM, Docker 등)
		- 프로세스마다 자기만의 가상 메모리 공간을 갖도록 OS가 가상화한다.

	- 클라우드를 구성하는 핵심 기술.
	- 물리적인 하드웨어 장치를 논리적인 객체로 추상화한다.
	- 하나의 자원을 여러개 처럼 동작시키거나 반대로 여러개로 묶어 하나의 장치처럼 쓸 수 있게 하여 효율적인 자원 관리를 도움.

	- 1세대
		- 완전 가상화
		- 모든 시스템 요소가 에뮬레이터 안에서 돌아감.
		- os가 여러개로 쪼개져서 가상화가 맞으나, 엄청나게 느림.

	- 2세대
		- Paravirtualization
		- 게스트 os들이 하이퍼바이저와 통신함. (하이퍼바이저 : os와 하드웨어 사이에 존재하는 일종의 가상화 매니저, 각 os가 말하는 명령들을 하드웨어가 이해할 수 있게 하나의 명령어로 번역해줌.)
		- 속도가 향상 됐지만 몇몇 요소의 경우 여전히 에뮬레이터가 필요해서 느리다.

	- 3세대
		- Hardware Virtual Machine(HVM)
		- 하드웨어에서 직접 가상화를 지원.
		- 직접 게스트 os가 하드웨어랑 통신하므로 빠른 속도를 보임.

	- 클라우드와 가상화는 밀접한 관계에 있다. 클라우드 환경에서 리소스를 작은 단위로 빠르게 구성할 수 있는 원동력은 가상화이다. aws의 경우, 사용자마다 컴퓨터를 할당해주는게 아니라 이미 구축된 가상화 가능한 서버의 한 부분을 할당해주는 것이다.

* GCC (GNU Compiler Collection)
	- C언어를 컴파일할 때 사용하는 대표적인 컴파일.
		- -Wall: 모든 경고 메시지를 표시
		- -g: 디버깅 정보 포함
		- -O2: 최적화 옵션

	- 컴파일러 모음을 줄여서 부르는 명칭이다.
	- 여러 소프트웨어들이 자유롭게 돌아갈 수 있는 기반 생태계를 구축하기 위해 시작한 프로젝트다.
	- 컴파일러 : 어떤 언어의 코드를 다른 언어로 바꿔주는 과정. (사람이 작성한 C언어를 컴퓨터가 이해할 수 있는 기계어로 바꿔주는 컴파일 과정을 해주는 번역기이다.)
	
	- 과정
		- 1. 전처리 -> 전처리기
		- 2. 컴파일 -> 컴파일러
		- 3. 어셈블 -> 어셈블러
		- 링크 -> 링커

* 동적 메모리 할당
	- 컴퓨터 프로그래밍에서 실행 중(런타임)에 사용할 메모리 공간을 할당하는 것을 의미.
	- 프로그램이 실행되기 위해서는 메모리가 필요한데, 컴파일러는 컴파일 시점에 소스 코드를 읽고, 변수 타입들의 크기에 따라 메모리를 할당한다.
	
	- 정적 할당(static allocation) : 프로그램이 실행되기 전, 컴파일 시점에 소스 코드를 읽고 메모리 공간을 확보하는 것.
	
	- 동적 할당(dynamic allocation) : 컴파일 타임이 아닌 프로그램이 실행되는 중인 런타임에 필요한 만큼의 메모리 공간을 확보하는 것.
		- 동적 할당이 필요한 이유는 무엇일까?
			- 그때그때 필요한 만큼만 메모리 공간을 확보하고, 다 사용했다면 free 시켜줌으로써 메모리 공간을 해제함으로서 한정된 메모리 공간을 효율적으로 사용할 수 있게 되는 것이다.

		- 힙(heap) 영역
			- C언어나 자바와 같은 프로그래밍 환경에서 원시 자료형(primitive type)이 아닌 보다 큰 크기의 데이터를 담고자 동적으로 할당하는 메모리 공간을 지칭한다.
		
		- --> C언어에서 말하는 동적할당이란 힙 영역에 필요할 때마다 메모리 공간을 할당하고, 더 이상 필요하지 않을 경우 메모리를 해제해주는 과정을 의미.
		
		- 장점
			- 상황에 따라 원하는 크기 만큼의 메모리가 할당되므로 경제적이다. (malloc 또는 calloc)
			- 이미 할당된 메모리라도 언제든 크기를 조정할 수 있다. (realloc)
		- 단점
			- C언어의 경우 GC(Garbage Collector)가 없기 때문에, 개발자가 직접 명시적으로 메모리를 해제해주어야한다. (free)
			- 만약 위 과정을 진행하지 않았을 경우, 메모리 누수가 나타나고 이는 디버깅 하기 매우 까다로워진다.

	- 메모리 할당
		- malloc 또는 calloc을 호출하게 되면 힙 영역에 필요한 만큼의 메모리 공간을 확보하고 이후 반환 타입으로 해당 메모리 공간의 시작 위치를 포인터로 반환한다. 또한 할당된 메모리를 어떤 목적에 사용할지 함수에서 판단하기 어렵기 때문에, return 타입은 void* 형을 return 하며, 반환 받는 쪽에서 타입 캐스팅을 통해 사용해야 한다.
	
		- malloc과 calloc의 차이
			- malloc : 매개변수로 입력한 크기 만큼을 그대로 할당하는 것.
			- calloc : 두번째 매개변수의 크기를 첫번째 매개변수 개수 만큼을 할당해 달라식으로 요청함.
			- 둘다 똑같은 크기의 공간을 확보한다.

			- 차이점이라고 하면, 초기화 값이 있다. malloc의 경우에는 메모리 공간만 할당하므로, 초기화되지 않은 메모리 공간에는 쓰레게 값들이 들어있다. 그러나 calloc은 할당 후 해당 메모리 공간을 0으로 초기화한다.

			- 성능 자체는 malloc이 조금 더 낫지만, 상황에 따라 다르다고 함.

	- 메모리 해제
		- 메모리 공간을 할당하였고, 원하는 동작들을 모두 수행했다면 할당된 메모리 공간을 해제해주어야 한다.
		- 메모리 공간은 한정적이며, 더 이상 사용되지 않을 메모리 공간이라면 해당 메모리 공간을 할당 해제 해줌으로써 다른 프로그램이 해당 공간을 재활용할 수 있게 된다. (C언어에서는 free 함수를 이용해 특정 주소의 메모리 공간을 할당 해제 해줄 수 있다.)

	- 메모리 누수 (Memory leak)
		- 동적으로 할당한 메모리가 할당 해제(free) 될 수 없는 상태가 된 것을 의미.
		- 이러한 상황이 반보고디면 동적으로 할당된 메모리가 해제되지 못하고 계속 남아있게 되기 때문에, 결국 시스템의 메모리가 부족해져 운영체제가 메모리 할당에 실패하여 프로그램을 종료시키게 된다.
		- malloc 또는 calloc을 사용하였다면, 의식적으로 free를 사용하는 습관을 들여야하며, 동적 메모리할당을 한 포인터의 주소를 직접 바꾸는 코드는 작성하지 않는 것이 메모리 누수를 방지할 수 있다.

	- 메모리 재할당
		- 이미 할당되어 있는 메모리 공간의 크기를 변경하여 재할당 하는 것을 의미한다.
		- 재할당은 realloc 함수를 이용해 메모리 공간 재할당이 가능하다.

* B 트리
	- 균형 잡힌 다진 트리로, 데이터베이스나 파일 시스템에서 자주 사용됨.
		- 노드에 여려 개의 키와 자식 포인터를 가질 수 있음.
		- 이진 탐색 트리보다 높이를 낮춰 탐색을 빠르게 함.
		- B트리는 보통 차수(degree)를 기준으로 설계됨.
		- C로 직접 구현하려면, struct, 포인터 배열 등을 써야한다.
		- 트리의 높이를 줄여서 디스크 I/O 횟수를 줄이 것이 핵심.
		- 모든 리프 노드가 동일한 레벨에 위치.

	- 컴퓨터 시스템 측면에서 B-tree
		- 데이터베이스와 파일 시스템에서 널리 사용되는 트리 자료구조의 일종.
		- 1. B-tree 노드의 키(Key) 개수는 수백, 수천 개까지 가질 수 있다.
		- 2. B-tree 노드의 자식노드는 부모의 키(key) 개수 + 1 이다.
		- 3. 모든 리프(leaf)노드는 깊이가 같다. (리프 노드 : 자식이 없는 노드)

		- -> 이러한 특성 덕분에 디스크 접근 횟수를 줄여서 연산 속도롤 빠르게 할 수 있다고 함.
		- 연산의 속도를 크게 좌지우지하는 디스크 접근 횟수를 최소화 하기 위해, 노드의 키 개수와 자식 개수를 크게 만들어 활용한다고 생각할 수 있다고 한다. 보통 루크 노드는 메인메모리에 있고, 그 아래 노드들에 접근하기 위해 디스크 접근을 한다고 생각하면 된다고 함.
	
	- 구조 및 자료구조 측면에서 B-tree 
		- B-tree의 각 노드에는 키 정보와 그 자식노드를 가리키는 포인터 정보가 들어있다. 또 리프 노드 정보도 들어있다.
		- T.root를 루트 노드로 가짐.
		- B-tree인 T의 특징
			- 1. 모든 노드 안에 키는 오름차순으로 정렬되어있다.
			- 2. 노드의 각 키는 서브 트리(자식 노드들)에 저장되는 키들의 범위를 분할한다.
			- 3. 노드의 키 개수는 t-1개이상, 2t-1개 이하이다. 즉, 최소 t-1개, 최대 2t-1개의 키 개수를 갖는다.

	- 특징(정리 및 추가)
                - 차수 (Degree, t): 한 노드가 가질 수 있는 최대 자식 수
                - 최소 키 수 : t-1
                - 최대 키 수 : 2t-1
                - 루트는 최소 1개 키를 갖고, 나머지 노드는 최소 t-1개 키를 가짐.

        - 주요 연산
                - 삽입 (Insert)
                        - 리프 노드에 삽입
                        - 노드가 가득 차면 분할(split) 필요
                - 삭제 (Delete) : 삭제 후 재배치 또는 병합(merge) 발생 가능
                - 탐색 (Search) : 각 노드에서 키들을 선형 검색하면서 탐색 진행

* 위상 정렬
	- 방향 그래프에서 순서를 정하는 알고리즘. (선수 과목 문제 같은..)
	- 사이클이 없는 DAG에서만 가능하다.
	- 대표적인 알고리즘: 진입 차수(indegree) 방식

	- 위상 정렬 방법
		- 1) 진입 차수(내차수)가 0인 임의의 정점(선행자가 없는 정점) 출력
		- 2) 출력한 정점에 부착된 모든 예지들을 제거하여 진입 차수 재계산
		- 3) 모든 정점들이 제거될 떄까지 1,2번을 반
		- 4) 진입 차수가 0인 것이 없으면, 그래프가 사이클을 포함한 것으로서 해가 존재하지 않음

* Binary Search Tree (BST) - 이진 탐색 트리
	- 각 노드에 최대 두 개의 자식 노드를 가지는 트리 구조로,왼쪽 자식은 부모보다 작고, 오른쪽 자식은 부모보다 크다.
	- 탐색, 삽입, 삭제의 평균 시간 복잡도는 O(log n) (균형이 잡혔을 때의 경울라고 함.)
	- 비균형 트리는 최악의 경우 선형 구조가 되어 시간 복잡도 O(n)

	- 주요 연산
		- 삽입 (Insert) : 루트에서 시작해 삽입할 위치를 찾아가면 비교 후 삽입.
		- 탐색 (Search) : 삽입과 같은 방식으로 원하는 값을 탐색.
		- 삭제 (Delete)
			- 자식이 없는 경우 -> 그냥 삭제
			- 자식이 하나 -> 부모와 자식 연
			- 자식이 둘 -> 오른쪽 서브트리의 최소값 또는 왼쪽 서브트리의 최대값으로 대체 후 삭제

	- 순회 (Traversal)
		- 중위 순회 (In-order) : 왼쪽 -> 현재 -> 오른쪽 (오름차순 출력)
		- 전위 순회 (Pre-order) : 현재 -> 왼쪽 -> 오른쪽
		- 후위 순회 (Post-order) : 왼쪽 -> 오른쪽 -> 현재
